# coding: utf-8

from sage.rings.polynomial.multi_polynomial_ideal import MPolynomialIdeal
from sage.rings.polynomial.polynomial_gf2x import GF2X_BuildIrred_list
from collections import deque

import sage.libs.singular.function_factory
eliminate = sage.libs.singular.function_factory.ff.eliminate

n = 16
testing_polys = False
debug = False

K = GF(2**n, "a")
K.inject_variables()

#################################################################
# Helper functions
#################################################################

def shift(seq, k=0):
    seq_d = deque(seq)
    seq_d.rotate(k)
    return list(seq_d)

def pow_cust(n, e):
    res = pow(K(n), e)
    return res

def evaluate(list, element):
    return sum([list[i]*pow_cust(element, 2^i) for i in range(len(list))])

def build_linearized_polynomial():
    prot = y^2
    while not(prot.is_irreducible()):
        c2 = K.random_element()
        c1 = K.random_element()
        prot = y^3+c2*y+c1
    return (prot*y).coefficients()

def inverse_polynomial(coefficients):
    coeff = coefficients + [0 for i in range(n-3)]
    m = matrix([map(lambda el : pow_cust(el, (2^i)), shift(coeff, i)) for i in range(len(coeff))])
    adj = m.adjoint()
    det = sum([adj[0][i]*pow_cust(coeff[(n-i)%n], (2^i)) for i in range(len(coeff))])
    factor = (1/det)
    if debug:
        print "Inverse built."
    return [adj[0][i]*factor for i in range(n)]

def polynomial_representation(poly):
    pr = sum(map(lambda (coeff, var) : coeff*var, zip(poly,[1,y,y^2,y^4])))
    return pr

def get_elimination_ideal(F, variables, deg_bound=None, algorithm="singular:slimgb", *args, **kwds):
    """
    Compute univariate polynomials in the ideal generated by F.

    :param F: polynomial system
    :param variables: variables
    :param deg_bound: if not ``None`` check if deg_bound suffices for computing GB.
        If ``True`` use regular-sequence bound.

    """
    P = PolynomialRing(K, variables, order="degrevlex")
    F = Sequence([P(f) for f in F])
    print "n_v: {n_v:3d}, n_e: {n_e:3d}, max_deg: {d:3d}".format(n_v=F.nvariables(), n_e=len(F), d=F.maximal_degree())

    gb = None
    if deg_bound:
        ideal = Ideal(F)
        print "Dimension of R/I as vector space:", len(ideal.normal_basis())
        H = ideal.change_ring(P.change_ring(order="degrevlex")).gens()
        print "n: {n:3d}, m: {m:3d}, max(deg(f)): {d:3d},".format(n=F.nvariables(), m=len(F), d=H.maximal_degree())
        if deg_bound is True:
            deg_bound = 1 + sum(f.degree() - 1 for f in H)
        if deg_bound < H.maximal_degree():
            raise ValueError("Degree bound %d is smaller than input degrees %d."%(deg_bound, H.maximal_degree()))
        t = walltime()
        gb = H.groebner_basis(deg_bound=deg_bound, algorithm=algorithm, *args, **kwds)
        print "GB time: {t:5.1f}s".format(t=walltime(t))
        print "deg_bound: {deg_bound:3d}, is GB: {is_gb}".format(deg_bound=deg_bound, is_gb=gb.is_groebner())
        if not gb.is_groebner():
            raise ValueError("Degree bound %d too low, output is not a GrÃ¶bner basis."%deg_bound)

    if gb == None:
        ideal = Ideal(F)
        print "Dimension of R/I as vector space:", len(ideal.normal_basis())
        t = walltime()
        gb = F.groebner_basis(algorithm=algorithm, *args, **kwds)
        print "GB time: {t:5.1f}s".format(t=walltime(t))

    t = walltime()
    gb_lex = Ideal(gb).transformed_basis('fglm')
    print "FGLM time: {t:5.1f}s".format(t=walltime(t))

    univariate = Sequence([f for f in gb_lex if f.is_univariate()])
    return univariate

def solve(eqns, vars, rem_var, deg_bound, *args, **kwds):

  P = PolynomialRing(K, vars)
  
  # Print degrees
  if debug:
    for eq in eqns:
        print "Degree:", P(eq).degree()

  # Get elimination ideal
  elGB = get_elimination_ideal(eqns, vars, deg_bound=deg_bound, *args, **kwds)
  if debug:
      print "Length of elimination ideal:", len(elGB)

  # Solve univariate equation    
  Q = PolynomialRing(K, rem_var)
  elim = Q(elGB[0])
  t = walltime()
  sols = [el[0] for el in set(elim.roots(ring=K))]    
  print "FACT time: {t:5.1f}s".format(t=walltime(t))
  print "Degree of univariate equation:", elim.degree()
  
  return sols    

#################################################################
# Build polynomials B,C
#################################################################

R.<y> = PolynomialRing(K)
T = PolynomialRing(K, "d4, d2, d1, d0, e4, e2, e1, e0")
T.inject_variables()

LB = build_linearized_polynomial()
LC = build_linearized_polynomial()
LB_inv = inverse_polynomial(LB)
LC_inv = inverse_polynomial(LC)
B = [K.random_element()]+LB
C = [K.random_element()]+LC
polyB = polynomial_representation(B)
polyC = polynomial_representation(C)

if testing_polys:
    random_element = K.random_element()
    d1 = evaluate(LB, random_element)+B[0]
    d2 = evaluate(LB_inv,d1+B[0])
    d3 = evaluate(LC, random_element)+C[0]
    d4 = evaluate(LC_inv, d3+C[0])
    print hex(random_element.integer_representation())
    print hex(d1.integer_representation())
    print hex(d2.integer_representation())
    print hex(d3.integer_representation())
    print hex(d4.integer_representation())


#################################################################
# Build polynomials D,E for optimized attack
#################################################################

W.<y> = PolynomialRing(T)

D = [d0, d1, d2, d4]
E = [e0, e1, e2, e4]
polyD = polynomial_representation(D)
polyE = polynomial_representation(E)

S = polyD(W(polyB))-polyE(W(polyC))
G = Ideal(S.coefficients()).groebner_basis()
ms = []
for g in G:
    dic = g.dict().items()
    ms.append(sum(v for v in [vector(map(lambda el : el*v, k)) for k,v in dic]))
ms = matrix(K, ms)
kernel = (ms.right_kernel()).basis()
solution = kernel[0]
d4 = solution[0]
d2 = solution[1]
d1 = solution[2]
d0 = solution[3]
e4 = solution[4]
e2 = solution[5]
e1 = solution[6]
e0 = solution[7]

polyD = R(polyD.substitute(d4=d4, d2=d2, d1=d1, d0=d0))
polyE = R(polyE.substitute(e4=e4, e2=e2, e1=e1, e0=e0))
D = polyD.coefficients()
E = polyE.coefficients()

if debug:
    print "Transformations are valid:", polyD(polyB) == polyE(polyC)


#################################################################
# Implementation of Jarvis and Friday
#################################################################

#a = K._cache.fetch_int(0x5AE9667C3B88E3AE1E6624620FB82AB3)
#b = K._cache.fetch_int(0xAF0646A28CFEF44DC1F30203CEFDD653)
#con = K._cache.fetch_int(0x23FBFF5E251E0083AC2133B13D4BB89A)
a = K.random_element()
b = K.random_element()
con = K.random_element()

def jarvis_ks(key, num_rounds):
    rks = [key]
    rcon = con
    for r in range(0, num_rounds):
        # be CAREFUL! the key schedule has been changed because of some denotational mistake in the orignal MARVELlous paper
        # rcon = a * rcon + b
        key = key^(2^n - 2) + rcon
        rcon = a * rcon + b
        rks.append(key)
    return rks

def jarvis_enc(plaintext, key, num_rounds, print_intermediate=False):
    rks = jarvis_ks(key, num_rounds)

    ciphertext = plaintext + rks[0]
    for r in range(0, num_rounds):
        ciphertext = ciphertext^(2^n - 2)
        ciphertext = evaluate(LB_inv, ciphertext+B[0])
        if print_intermediate == True:
            print ("x_" + str(r+1) + ":"), hex(ciphertext.integer_representation())
        ciphertext = evaluate(LC, ciphertext)+C[0]
        ciphertext = ciphertext + rks[r+1]

    return ciphertext

def jarvis_dec(ciphertext, key, num_rounds):
    rks = jarvis_ks(key, num_rounds)
    rks.reverse()

    plaintext = ciphertext
    for r in range(0, num_rounds):
        plaintext = plaintext + rks[r]
        plaintext = evaluate(LC_inv, plaintext+C[0])
        plaintext = evaluate(LB, plaintext)+B[0]
        plaintext = plaintext^(2^n - 2)
    plaintext = plaintext + rks[num_rounds]

    return plaintext

# Assuming len(input) = 1
def friday(input, num_jarvis_rounds, IV = 0, print_intermediate = False):
    # IV = 0 according to paper
    block = input[0]
    output = jarvis_enc(block, IV, num_jarvis_rounds, print_intermediate) + IV + block
    return output


#################################################################
# Attacks on Friday
#################################################################

def friday_attack(input, num_jarvis_rounds, IV = 0, optimized=False, print_intermediate=False, deg_bound=None, *args, **kwds):
    h_0 = IV
    h_1 = friday(input, num_jarvis_rounds, h_0, print_intermediate)
    rks = jarvis_ks(h_0, num_jarvis_rounds)

    # Set up variables
    variables = []
    for i in range(1,num_jarvis_rounds+1):
        variables.append("x_"+str(i))
    P = PolynomialRing(K, variables)
    P.inject_variables()
    variables = [P(v) for v in variables]

    # Set up system of equations
    equations = []
    elGB = None
    if not(optimized):
        # non-optimized equations
        for i in range(num_jarvis_rounds):

			# TODO! adjust unoptimised equations

            if i < num_jarvis_rounds - 1:
                equations.append((polyC(variables[i]) + rks[i+1]) * polyB(variables[i+1]) + 1)
            elif i == num_jarvis_rounds - 1:
                equations.append(polyB(variables[0]) * (polyC(variables[num_jarvis_rounds-1]) + rks[num_jarvis_rounds] + H2) + 1)

    else:
		# optimized-equations
		# for 3 rounds
		if num_jarvis_rounds == 3:
			variables = [x_1, x_3]
			# Append equation for intermediate states
			eq = polyD(1/(polyC(x_1)+rks[1]))*((polyC(x_1)+rks[1])^4)*((polyB(x_3))^4) - polyE(1/polyB(x_3) + rks[2])*((polyC(x_1)+rks[1])^4)*((polyB(x_3))^4)
			equations.append(eq)
			# Append equation for hash value
			equations.append(polyB(x_1)*(polyC(x_3)+rks[3]+h_1)+1)
			
		# for 4 rounds
		if num_jarvis_rounds == 4:
			variables = [x_2, x_4]
			# Append equation for intermediate states
			com_denom = (polyC(x_2)+rks[2])^4*(polyB(x_4))^4
			eq = polyD(1/(polyC(x_2)+rks[2]))*com_denom - polyE(1/polyB(x_4) + rks[3])*com_denom
			equations.append(eq)
			# Append equation for hash value
			com_denom = (polyC(x_4)+rks[4]+h_1)^4*polyB(x_2)^4
			eq = polyD(1/(polyC(x_4)+rks[4]+h_1))*com_denom + polyE(1/polyB(x_2)+rks[1])*com_denom
			equations.append(eq)


		# for 5 rounds
		if num_jarvis_rounds == 5:
			variables = [x_1, x_3, x_5]
			eq1 = polyD(1/(polyC(x_1)+rks[1]))*((polyC(x_1)+rks[1])*(polyB(x_3)))^4 - polyE(1/polyB(x_3) + rks[2])*((polyC(x_1)+rks[1])^4)*((polyB(x_3))^4)
			equations.append(eq1)
			eq2 = polyD(1/(polyC(x_3)+rks[3]))*((polyC(x_3)+rks[3])^4)*((polyB(x_5))^4) - polyE(1/polyB(x_5) + rks[4])*((polyC(x_3)+rks[3])^4)*((polyB(x_5))^4)
			equations.append(eq2)
			equations.append(polyB(x_1)*(polyC(x_5)+rks[5]+h_1)+1)

		# for 6 rounds
		if num_jarvis_rounds == 6:
			variables = [x_2, x_4, x_6]
			# Append equation for intermediate states
			com_denom = (polyC(x_2)+rks[2])^4*(polyB(x_4))^4
			eq = polyD(1/(polyC(x_2)+rks[2]))*com_denom - polyE(1/polyB(x_4) + rks[3])*com_denom
			equations.append(eq)
			com_denom = (polyC(x_4)+rks[4])^4*(polyB(x_6))^4
			eq = polyD(1/(polyC(x_4)+rks[4]))*com_denom - polyE(1/polyB(x_6) + rks[5])*com_denom
			equations.append(eq)
			# Append equation for hash value
			com_denom = (polyC(x_6)+rks[6]+h_1)^4*polyB(x_2)^4
			eq = polyD(1/(polyC(x_6)+rks[6]+h_1))*com_denom + polyE(1/polyB(x_2)+rks[1])*com_denom
			equations.append(eq)
		
    remaining_variable = "x_" + str(num_jarvis_rounds)
    sols = solve(equations, variables, remaining_variable, deg_bound, *args, **kwds)
    for s in sols:
        preimage = (evaluate(LC,s)+C[0])+rks[num_jarvis_rounds] + h_0 + h_1
        print "Preimage:", hex(preimage.integer_representation())
        print "Hash:", hex(friday([preimage], num_jarvis_rounds).integer_representation())
    if len(sols) == 0:
        return False
    return True


#################################################################
# Attacks on Jarvis
#################################################################

def derive_keys(master_key, num_rounds):
    # get all the round constants c_0,..,c_{r-1} from the key schedule
    constants = []
    constants.append(con)
    rcon = con
    for r in range(1, num_rounds):
        # append constants for c_i, i=1,...,r-1
        rcon = a * rcon + b
        constants.append(rcon)

    # Set up coefficients alpha, beta, gamma, delta to express the round keys as
    # rational functions of k_0
    # append constants for k_0
    derived = [(1,0,0,1)]
    # append constant for k_1
    derived.append(( constants[0], K._cache.fetch_int(1), K._cache.fetch_int(1), K._cache.fetch_int(0) ))
    alpha = derived[1][0]
    beta = derived[1][1]
    gamma = derived[1][2]
    delta = derived[1][3]
    # append constants for k_i, i=2,...,r
    for i in range(2,num_rounds+1):
        # formula is alpha_{i+1} = alpha_{i} * c_{i+1} + gamma_{i}
        # e.g. for k_2 the constant c_1 is needed, which is stored in constants[1]
        intermed_alpha = alpha
        intermed_beta = beta
        alpha = alpha * constants[i-1] + gamma
        beta = beta * constants[i-1] + delta
        gamma = intermed_alpha
        delta = intermed_beta
        derived.append((alpha, beta, gamma, delta))
    return derived


def jarvis_attack(plaintext, master_key, num_rounds, deg_bound=None, *args, **kwds):
    ciphertext = jarvis_enc(plaintext, master_key, num_rounds)

    variables = []
    # add even intermediate states x_2,x_4,...,x_r as variables
    for i in range(2,num_rounds+1,2):
        variables.append("x_"+str(i))
    if num_rounds == 1:
        variables.append("x_1")
    # add a variable for the master key k_0
    variables.append("k_0")
    P = PolynomialRing(K, variables, order="degrevlex")
    P.inject_variables()
    variables = [P(v) for v in variables]

    # Get constants alpha, beta, gamma, delta to express other round keys
    # as a rational function in k_0
    const = derive_keys(master_key, num_rounds)
    if debug:
      flag = True
      keys = jarvis_ks(master_key, num_rounds)
      for i in range(len(const)):
        if not(keys[i] == (const[i][0]*master_key + const[i][1])/(const[i][2]*master_key + const[i][3])):
          flag = False
          break
      print "Rational representations for round keys are valid:", flag

    equations = []
    elimination_variables = []
    # optimized-equations

    # for 1 round
    if num_rounds == 1:
        eq = (plaintext+k_0) * polyB(x_1) - 1
        equations.append(eq)
        com_denom = const[1][2]*k_0+const[1][3]
        eq = polyC(x_1)*com_denom + const[1][0]*k_0+const[1][1] + ciphertext*com_denom
        equations.append(eq)
        elimination_variables = [x_1]
        
    # for 2 rounds
    if num_rounds == 2:
        com_denom = (plaintext+k_0)^4*(polyB(x_2)*(const[1][2]*k_0+const[1][3]))^4
        eq = polyD(1/(plaintext+k_0))*com_denom + polyE((const[1][2]*k_0+const[1][3]+polyB(x_2)*(const[1][0]*k_0+const[1][1]))/(polyB(x_2)*(const[1][2]*k_0+const[1][3])))*com_denom
        equations.append(eq)

        com_denom = const[2][2]*k_0+const[2][3]
        eq = polyC(x_2)*com_denom + const[2][0]*k_0+const[2][1] + ciphertext*com_denom
        equations.append(eq)
        elimination_variables = [x_2]

    # for 3 rounds
    if num_rounds == 3:
        # append equation for plaintext
        if debug:
            print "Set up equation for plaintext...",
        com_denom = (plaintext+k_0)^4*(polyB(x_2)*(const[1][2]*k_0+const[1][3]))^4
        eq = polyD(1/(plaintext+k_0))*com_denom + polyE((const[1][2]*k_0+const[1][3]+polyB(x_2)*(const[1][0]*k_0+const[1][1]))/(polyB(x_2)*(const[1][2]*k_0+const[1][3])))*com_denom
        equations.append(eq)
        if debug:
            print "...done."
        # append equation for ciphertext
        if debug:
            print "Set up equation for ciphertext...",
        com_denom = (polyC(x_2)*(const[2][2]*k_0+const[2][3])+const[2][0]*k_0+const[2][1])^4*(const[3][2]*k_0+const[3][3])^4
        eq = polyD((const[2][2]*k_0+const[2][3])/(polyC(x_2)*(const[2][2]*k_0+const[2][3])+const[2][0]*k_0+const[2][1]))*com_denom + polyE((const[3][0]*k_0+const[3][1]+ciphertext*(const[3][2]*k_0+const[3][3]))/(const[3][2]*k_0+const[3][3]))*com_denom
        equations.append(eq)
        if debug:
            print "...done."
        elimination_variables = [x_2]

    # for 4 rounds
    if num_rounds == 4:
        com_denom = (plaintext+k_0)^4*(polyB(x_2)*(const[1][2]*k_0+const[1][3]))^4
        eq = polyD(1/(plaintext+k_0))*com_denom + polyE((const[1][2]*k_0+const[1][3]+polyB(x_2)*(const[1][0]*k_0+const[1][1]))/(polyB(x_2)*(const[1][2]*k_0+const[1][3])))*com_denom
        equations.append(eq)
        # Append equation for intermediate states..."
        com_denom = (polyC(x_2)*(const[2][2]*k_0+const[2][3])+const[2][0]*k_0+const[2][1])^4*(polyB(x_4)*(const[3][2]*k_0+const[3][3]))^4
        eq = polyD((const[2][2]*k_0+const[2][3])/(polyC(x_2)*(const[2][2]*k_0+const[2][3])+const[2][0]*k_0+const[2][1]))*com_denom + polyE((const[3][2]*k_0+const[3][3]+polyB(x_4)*(const[3][0]*k_0+const[3][1]))/(polyB(x_4)*(const[3][2]*k_0+const[3][3])))*com_denom
        equations.append(eq)
        # Append equation for ciphertext
        eq = (polyC(x_4)+ciphertext)*(const[4][2]*k_0+const[4][3])+const[4][0]*k_0+const[4][1]
        equations.append(eq)

    # for 5 rounds
    if num_rounds == 5:
        com_denom = (plaintext+k_0)^4*(polyB(x_2)*(const[1][2]*k_0+const[1][3]))^4
        eq = polyD(1/(plaintext+k_0))*com_denom + polyE((const[1][2]*k_0+const[1][3]+polyB(x_2)*(const[1][0]*k_0+const[1][1]))/(polyB(x_2)*(const[1][2]*k_0+const[1][3])))*com_denom
        equations.append(eq)
        com_denom = (polyC(x_2)*(const[2][2]*k_0+const[2][3])+const[2][0]*k_0+const[2][1])^4*(polyB(x_4)*(const[3][2]*k_0+const[3][3]))^4
        eq = polyD((const[2][2]*k_0+const[2][3])/(polyC(x_2)*(const[2][2]*k_0+const[2][3])+const[2][0]*k_0+const[2][1]))*com_denom + polyE((const[3][2]*k_0+const[3][3]+polyB(x_4)*(const[3][0]*k_0+const[3][1]))/(polyB(x_4)*(const[3][2]*k_0+const[3][3])))*com_denom
        equations.append(eq)
        # Last equation
        com_denom = (polyC(x_4)*(const[4][2]*k_0+const[4][3])+const[4][0]*k_0+const[4][1])^4*(const[5][2]*k_0+const[5][3])^4
        eq = polyD((const[4][2]*k_0+const[4][3])/(polyC(x_4)*(const[4][2]*k_0+const[4][3])+const[4][0]*k_0+const[4][1]))*com_denom + polyE((const[5][0]*k_0+const[5][1]+ciphertext*(const[5][2]*k_0+const[5][3]))/(const[5][2]*k_0+const[5][3]))*com_denom
        equations.append(eq)

    # for 6 rounds
    if num_rounds == 6:
        if debug:
            print "Set up equation for plaintext.",
        com_denom = (plaintext+k_0)^4*(polyB(x_2)*(const[1][2]*k_0+const[1][3]))^4
        eq = polyD(1/(plaintext+k_0))*com_denom + polyE((const[1][2]*k_0+const[1][3]+polyB(x_2)*(const[1][0]*k_0+const[1][1]))/(polyB(x_2)*(const[1][2]*k_0+const[1][3])))*com_denom
        equations.append(eq)
        # Append equation for intermediate states"
        com_denom = (polyC(x_2)*(const[2][2]*k_0+const[2][3])+const[2][0]*k_0+const[2][1])^4*(polyB(x_4)*(const[3][2]*k_0+const[3][3]))^4
        eq = polyD((const[2][2]*k_0+const[2][3])/(polyC(x_2)*(const[2][2]*k_0+const[2][3])+const[2][0]*k_0+const[2][1]))*com_denom + polyE((const[3][2]*k_0+const[3][3]+polyB(x_4)*(const[3][0]*k_0+const[3][1]))/(polyB(x_4)*(const[3][2]*k_0+const[3][3])))*com_denom
        equations.append(eq)
        com_denom = (polyC(x_4)*(const[4][2]*k_0+const[4][3])+const[4][0]*k_0+const[4][1])^4*(polyB(x_6)*(const[5][2]*k_0+const[5][3]))^4
        eq = polyD((const[4][2]*k_0+const[4][3])/(polyC(x_4)*(const[4][2]*k_0+const[4][3])+const[4][0]*k_0+const[4][1]))*com_denom + polyE((const[5][2]*k_0+const[5][3]+polyB(x_6)*(const[5][0]*k_0+const[5][1]))/(polyB(x_6)*(const[5][2]*k_0+const[5][3])))*com_denom
        equations.append(eq)
        # Append equation for ciphertext
        eq = (polyC(x_6)+ciphertext)*(const[6][2]*k_0+const[6][3])+const[6][0]*k_0+const[6][1]
        equations.append(eq)

    # for 7 rounds
    if num_rounds == 7:
        # Append equation for plaintext
        com_denom = (plaintext+k_0)^4*(polyB(x_2)*(const[1][2]*k_0+const[1][3]))^4
        eq = polyD(1/(plaintext+k_0))*com_denom + polyE((const[1][2]*k_0+const[1][3]+polyB(x_2)*(const[1][0]*k_0+const[1][1]))/(polyB(x_2)*(const[1][2]*k_0+const[1][3])))*com_denom
        equations.append(eq)   
        # Append equations for intermediate states."
        com_denom = (polyC(x_2)*(const[2][2]*k_0+const[2][3])+const[2][0]*k_0+const[2][1])^4*(polyB(x_4)*(const[3][2]*k_0+const[3][3]))^4
        eq = polyD((const[2][2]*k_0+const[2][3])/(polyC(x_2)*(const[2][2]*k_0+const[2][3])+const[2][0]*k_0+const[2][1]))*com_denom + polyE((const[3][2]*k_0+const[3][3]+polyB(x_4)*(const[3][0]*k_0+const[3][1]))/(polyB(x_4)*(const[3][2]*k_0+const[3][3])))*com_denom
        equations.append(eq)
        com_denom = (polyC(x_4)*(const[4][2]*k_0+const[4][3])+const[4][0]*k_0+const[4][1])^4*(polyB(x_6)*(const[5][2]*k_0+const[5][3]))^4
        eq = polyD((const[4][2]*k_0+const[4][3])/(polyC(x_4)*(const[4][2]*k_0+const[4][3])+const[4][0]*k_0+const[4][1]))*com_denom + polyE((const[5][2]*k_0+const[5][3]+polyB(x_6)*(const[5][0]*k_0+const[5][1]))/(polyB(x_6)*(const[5][2]*k_0+const[5][3])))*com_denom
        equations.append(eq)
        # Append equation for ciphertext
        com_denom = (polyC(x_6)*(const[6][2]*k_0+const[6][3])+const[6][0]*k_0+const[6][1])^4*(const[7][2]*k_0+const[7][3])^4
        eq = polyD((const[6][2]*k_0+const[6][3])/(polyC(x_6)*(const[6][2]*k_0+const[6][3])+const[6][0]*k_0+const[6][1]))*com_denom + polyE((const[7][0]*k_0+const[7][1]+ciphertext*(const[7][2]*k_0+const[7][3]))/(const[7][2]*k_0+const[7][3]))*com_denom
        equations.append(eq)

    remaining_variable = "k_0"
    print "Solutions:"
    for s in solve(equations, variables, remaining_variable, deg_bound, *args, **kwds):
        print "K:",hex(s.integer_representation()), ", C:", hex(ciphertext.integer_representation()), ", E_K(P):", hex(jarvis_enc(plaintext, s, num_rounds).integer_representation())


def jarvis_attack_unoptimized(plaintext, master_key, num_rounds, deg_bound=None, *args, **kwds):
    ciphertext = jarvis_enc(plaintext, master_key, num_rounds)

    variables = []
    # add even intermediate states x_1,x_2,...,x_r as variables
    for i in range(1,num_rounds + 1):
        variables.append("x_"+str(i))
    # add a variable for the master key k_0
    variables.append("k_0")
    P = PolynomialRing(K, variables, order="degrevlex")
    P.inject_variables()
    variables = [P(v) for v in variables]

    # Get constants alpha, beta, gamma, delta to express other round keys
    # as a rational function in k_0
    const = derive_keys(master_key, num_rounds)
    
    if debug:
      flag = True
      keys = jarvis_ks(master_key, num_rounds)
      for i in range(len(const)):
        if not(keys[i] == (const[i][0]*master_key + const[i][1])/(const[i][2]*master_key + const[i][3])):
          flag = False
          break
      print "Rational representations for round keys are valid:", flag
        
    equations = []
    # unoptimized equations
    # Plaintext equation
    eq = polyB(x_1) * (plaintext + k_0) + 1
    equations.append(eq)

    # Intermediate equations
    for i in range(1, num_rounds):
        # k_i = (const[i][0] * k_0 + const[i][1]) / (const[i][2] * k_0 + const[i][3])
        com_denom = (const[i][2] * k_0 + const[i][3])
        eq = ((polyC(variables[i - 1]) * com_denom) + (const[i][0] * k_0 + const[i][1])) * polyB(variables[i]) + com_denom
        equations.append(eq)

    # Ciphertext equation
    # k_r = (const[num_rounds][0] * k_0 + const[num_rounds][1]) / (const[num_rounds][2] * k_0 + const[num_rounds][3])
    com_denom = const[num_rounds][2] * k_0 + const[num_rounds][3]
    eq = (polyC(variables[num_rounds - 1]) * com_denom) + (ciphertext * com_denom) + (const[num_rounds][0] * k_0+const[num_rounds][1])
    equations.append(eq)

    remaining_variable = "k_0"
    for s in solve(equations, variables, remaining_variable, deg_bound, *args, **kwds):
        print "K:",hex(s.integer_representation()), ", C:", hex(ciphertext.integer_representation()), ", E_K(P):", hex(jarvis_enc(plaintext, s, num_rounds).integer_representation())


#################################################################
# Run
#################################################################

def run_friday_attack(r=3, deg_bound=None, *args, **kwds):
    random_element = K.random_element()
    key = K.random_element()
    num_rounds = r
    encrypted = jarvis_enc(random_element, key, num_rounds, print_intermediate=False)
    decrypted = jarvis_dec(encrypted, key, num_rounds)
    hash = friday([random_element], num_rounds)
    print "Orig:", hex(random_element.integer_representation())
    print "Hash:", hex(hash.integer_representation())

    #for i in range(0, 100):
    res = friday_attack([random_element], num_rounds,
                        optimized=True,
                        print_intermediate=False,
                        deg_bound=deg_bound,
                        *args, **kwds)
    #print res
    if res == False:
        print "No solution found."
        #break

def run_jarvis_attack(r=3, deg_bound=None, optimized=True, *args, **kwds):
    k = K.random_element()
    print "Master key:", hex(k.integer_representation())
    p = K.random_element()
    if optimized == True:
        jarvis_attack(p, k, r, deg_bound=deg_bound, *args, **kwds)
    else:
        jarvis_attack_unoptimized(p, k, r, deg_bound=deg_bound, *args, **kwds)

#run_friday_attack(r=3, deg_bound=32)
#run_jarvis_attack(r=3, deg_bound=None)